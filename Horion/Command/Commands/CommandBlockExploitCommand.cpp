#include "CommandBlockExploitCommand.h"

#include <thread>

CommandBlockExploitCommand::CommandBlockExploitCommand() : IMCCommand("commandblockexploit", "Search and open commands from far range!", "<search/open/beehive> <range>/<x> <y> <z>/<command>") {
	registerAlias("cbe");
}

CommandBlockExploitCommand::~CommandBlockExploitCommand() {
}

void search(float range) {
	vec3_t* pos = g_Data.getLocalPlayer()->getPos();
	auto region = g_Data.getLocalPlayer()->region;
	for (float x = pos->x - range; x < pos->x + range; x++) {
		for (float z = pos->z - range; z < pos->z + range; z++) {
			for (float y = 0; y < 256; y++) {
				vec3_t pos(x, y, z);
				C_Block* block = region->getBlock(pos);
				if (block != nullptr) {
					int blockId = block->toLegacy()->blockId;
					if (blockId == 137 || blockId == 188 || blockId == 189) {
						g_Data.getGuiData()->displayClientMessageF("[%sHorion%s] %sCommand block found at %s%d, %d, %d%s!", GOLD, WHITE, GREEN, GRAY, (int)x, (int)y, (int)z, GREEN);
						return;
					}
				}
			}
		}
	}
	g_Data.getGuiData()->displayClientMessageF("[%sHorion%s] %sNo command blocks found!", GOLD, WHITE, GREEN);
}

bool CommandBlockExploitCommand::execute(std::vector<std::string>* args) {
	if (args->at(1) == "search") {
		float range = assertFloat(args->at(2));
		clientMessageF("[%sHorion%s] %sSearching for command blocks...", GOLD, WHITE, GREEN);
		std::thread searchThread(search, range);
		searchThread.detach();
		return true;
	} else if (args->at(1) == "open") {
		float x = assertFloat(args->at(2));
		float y = assertFloat(args->at(3));
		float z = assertFloat(args->at(4));

		auto forceOpenCmdBlockModule = moduleMgr->getModule<ForceOpenCommandBlock>();
		if (!forceOpenCmdBlockModule->isEnabled()) {
			clientMessageF("[%sHorion%s] %sEnable ForceCommandBlockOpen first!", GOLD, WHITE, GREEN);
			return true;
		}

		vec3_t pos(x, y, z);
		forceOpenCmdBlockModule->distance = g_Data.getLocalPlayer()->getPos()->dist(pos);
		forceOpenCmdBlockModule->isInCommandBlock = true;

		g_Data.getLocalPlayer()->openCommandBlock(pos);
		return true;
	} else if (args->at(1) == "beehive") {
		assertTrue(args->size() > 3);
		std::ostringstream os;
		for (int i = 2; i < args->size(); i++) {
			if (i > 2)
				os << " ";
			os << args->at(i);
		}
		using ItemRegistry__lookupByName_t = C_Item***(__fastcall*)(void*, void*, TextHolder);
		static ItemRegistry__lookupByName_t ItemRegistry__lookupByNameF = reinterpret_cast<ItemRegistry__lookupByName_t>(FindSignature("40 55 56 57 41 56 41 57 48 8D 6C 24 ? 48 81 EC ? ? ? ? 48 C7 45 ? ? ? ? ? 48 89 9C 24 ? ? ? ? 48 8B 05 ? ? ? ? 48 33 C4 48 89 45 48 48 8B F1 48 89 4D 80 45 33 FF 44 89 7C 24 ? 4D 39 78 10 75 23 "));
		void* ItemPtr = malloc(0x8);
		void* idk = malloc(0x0);
		C_ItemStack* yot = new C_ItemStack(***ItemRegistry__lookupByNameF(ItemPtr, idk, std::string("beehive")), 1, 0);
		free(ItemPtr);
		free(idk);
		int slot = g_Data.getLocalPlayer()->getSupplies()->inventory->getFirstEmptySlot();
		std::string cmd = os.str();
		std::string tag = "{Occupants:[{TicksLeftToStay:1,ActorIdentifier:\"minecraft:command_block_minecart<>\",SaveData:{definitions:[\"+minecraft:command_block_minecart\",\"+minecraft:command_block_inactive\"],CurrentTickCount:0,identifier:\"minecraft:command_block_minecart\",Variant:0,OnGround:1b,Command:\"" + cmd + "\",OwnerNew:-1l,IsGlobal:1b,Strength:0,TrackOutput:0b}}]}";
		yot->setUserData(std::move(Mojangson::parseTag(tag)));
		g_Data.getLocalPlayer()->getTransactionManager()->addInventoryAction(C_InventoryAction(0, yot, nullptr, 507, 99999));
		g_Data.getLocalPlayer()->getTransactionManager()->addInventoryAction(C_InventoryAction(slot, nullptr, yot));
		g_Data.getLocalPlayer()->getSupplies()->inventory->addItemToFirstEmptySlot(yot);
		clientMessageF("[%sHorion%s] %sPlace the beehive to spawn a command block minecart with a command already inside!", GOLD, WHITE, GREEN);
		return true;
	}
	return false;
}
