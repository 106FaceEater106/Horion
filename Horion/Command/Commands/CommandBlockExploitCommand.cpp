#include "CommandBlockExploitCommand.h"
#include <thread>

CommandBlockExploitCommand::CommandBlockExploitCommand() : IMCCommand("commandblockexploit", "Search and open commands from far range!", "<search/open> <range>/<x> <y> <z>") {
	registerAlias("cbe");
}

CommandBlockExploitCommand::~CommandBlockExploitCommand() {
}

void search(float range) {
	vec3_t* pos = g_Data.getLocalPlayer()->getPos();
	auto region = g_Data.getLocalPlayer()->region;
	for (float x = pos->x - range; x < pos->x + range; x++) {
		for (float z = pos->z - range; z < pos->z + range; z++) {
			for (float y = 0; y < 256; y++) {
				vec3_t pos(x, y, z);
				C_Block* block = region->getBlock(pos);
				if (block != nullptr) {
					int blockId = block->toLegacy()->blockId;
					if (blockId == 137 || blockId == 188 || blockId == 189) {
						g_Data.getGuiData()->displayClientMessageF("[%sHorion%s] %sCommand block found at %s%d, %d, %d%s!", GOLD, WHITE, GREEN, GRAY, (int)x, (int)y, (int)z, GREEN);
						return;
					}
				}
			}
		}
	}
	g_Data.getGuiData()->displayClientMessageF("[%sHorion%s] %sNo command blocks found!", GOLD, WHITE, GREEN);
}

bool CommandBlockExploitCommand::execute(std::vector<std::string>* args) {
	if (args->at(1) == "search") {
		float range = assertFloat(args->at(2));
		clientMessageF("[%sHorion%s] %sSearching for command blocks...", GOLD, WHITE, GREEN);
		std::thread searchThread(search, range);
		searchThread.detach();
		return true;
	} else if (args->at(1) == "open") {
		ForceOpenCommandBlock* yot = moduleMgr->getModule<ForceOpenCommandBlock>();
		if (!yot->isEnabled()) {
			clientMessageF("[%sHorion%s] %sEnable ForceCommandBlockOpen first!", GOLD, WHITE, GREEN);
			return true;
		}
		float x = assertFloat(args->at(2));
		float y = assertFloat(args->at(3));
		float z = assertFloat(args->at(4));
		vec3_t pos = vec3_t(x, y, z);
		yot->distance = g_Data.getLocalPlayer()->getPos()->dist(pos);
		yot->isInCommandBlock = true;
		g_Data.getLocalPlayer()->openCommandBlock(pos);
		return true;
	}
	return false;
}
